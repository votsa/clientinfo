/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ClientInfo = __webpack_require__(1);

	var _ClientInfo2 = _interopRequireDefault(_ClientInfo);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	window.ClientInfo = _ClientInfo2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _fontdetect = __webpack_require__(2);

	var _fontdetect2 = _interopRequireDefault(_fontdetect);

	var _webgldetect = __webpack_require__(3);

	var _webgldetect2 = _interopRequireDefault(_webgldetect);

	var _constants = __webpack_require__(4);

	var c = _interopRequireWildcard(_constants);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function isExist(what) {
	  return typeof what !== 'undefined';
	}

	var ClientInfo = function () {
	  function ClientInfo() {
	    _classCallCheck(this, ClientInfo);
	  }

	  _createClass(ClientInfo, [{
	    key: 'getJSVersion',

	    /**
	     * Detect javascript version
	     *
	     * @return {number} Current javascript version.
	     */
	    value: function getJSVersion() {
	      var script = void 0,
	          i = void 0,
	          jsVersion = void 0,
	          scriptArr = [];

	      for (i = 0; i < c.JS_VERSIONS.length; i++) {
	        script = document.createElement('script');
	        script.innerHTML = 'var jsver = ' + c.JS_VERSIONS[i] + ';';
	        script.setAttribute('language', 'Javascript' + c.JS_VERSIONS[i]);

	        // Save script element
	        scriptArr.push(script);

	        document.body.appendChild(script);
	      }

	      // Detect version
	      jsVersion = window.jsver;

	      // Remove scripts
	      for (i = 0; i < scriptArr.length; i++) {
	        document.body.removeChild(scriptArr[i]);
	      }

	      // Clean up
	      scriptArr = null;

	      return jsVersion;
	    }

	    /**
	     * Document referrer
	     *
	     * @return {string} Document referrer
	     */

	  }, {
	    key: 'getReferrer',
	    value: function getReferrer() {
	      return isExist(document.referrer) ? document.referrer : null;
	    }

	    /**
	     * Get installed fonts as array
	     *
	     * @return {array} Array of installed fonts.
	     */

	  }, {
	    key: 'getFonts',
	    value: function getFonts() {
	      var fontDetector = new _fontdetect2.default();
	      var fonts = [],
	          i = void 0;

	      for (i = 0; i < c.FONT_ARRAY.length; i++) {
	        if (fontDetector.detect(c.FONT_ARRAY[i])) {
	          fonts.push(c.FONT_ARRAY[i]);
	        }
	      }

	      return fonts;
	    }

	    /**
	     * Get installed fonts as string
	     *
	     * @return {string} String that contains installed fonts.
	     */

	  }, {
	    key: 'getFontsString',
	    value: function getFontsString() {
	      var fonts = this.getFonts();

	      return fonts.join(', ');
	    }

	    /**
	     * Detect installed font
	     *
	     * @param {string} font - Font name to detect
	     * @return {boolean} - Whether given font is installed
	     */

	  }, {
	    key: 'detectFont',
	    value: function detectFont(font) {
	      var fontDetector = new _fontdetect2.default();

	      return fontDetector.detect(font);
	    }

	    /**
	     * Get screen print
	     *
	     * @return {string} - Screen print
	     * @todo Add IE support
	     */

	  }, {
	    key: 'getScreenPrint',
	    value: function getScreenPrint() {
	      var size = this.getScreenSize();
	      var ratio = this.getScreenRatio();
	      var depth = this.getColorDepth();
	      var type = this.getColorType();
	      var workingArea = this.getWorkingAreaSize();

	      return workingArea.width + 'x' + size.height + ' ' + ratio + ' ' + depth + '-bit ' + type + ' {working area ' + workingArea.width + 'x' + workingArea.height + '}';
	    }

	    /**
	     * Get color dept
	     *
	     * @return {number} - Color depth
	     */

	  }, {
	    key: 'getColorDepth',
	    value: function getColorDepth() {
	      var screen = window.screen;

	      if (isExist(screen.colorDepth)) {
	        return screen.colorDepth;
	      } else if (isExist(screen.pixelDepth)) {
	        return screen.pixelDepth;
	      }

	      return null;
	    }

	    /**
	     * Get color type string
	     *
	     * @return {string} - Color type
	     */

	  }, {
	    key: 'getColorType',
	    value: function getColorType() {
	      var colorDepth = this.getColorDepth();

	      if (colorDepth >= 24) {
	        return 'TrueColor';
	      } else if (colorDepth >= 15) {
	        return 'HighColor';
	      }

	      return '';
	    }

	    /**
	     * Get screen ratio
	     *
	     * @return {string} - Screen ratio
	     */

	  }, {
	    key: 'getScreenRatio',
	    value: function getScreenRatio() {
	      var sizes = this.getScreenSize();
	      var width = sizes.width;
	      var height = sizes.height;

	      if (isExist(width) && isExist(height)) {
	        var ratio = Math.round(width / height * 100) / 100;

	        return c.RATIOS[ratio];
	      }

	      return null;
	    }

	    /**
	     * Get screen size
	     *
	     * @return {object} - Screen size object
	     */

	  }, {
	    key: 'getScreenSize',
	    value: function getScreenSize() {
	      var screen = window.screen;
	      var width = screen.width;
	      var height = screen.height;

	      if (isExist(width) && isExist(height)) {
	        return { width: width, height: height };
	      }

	      return {
	        width: 0,
	        height: 0
	      };
	    }

	    /**
	     * Get working area sizes
	     *
	     * @return {object} Working area size object
	     */

	  }, {
	    key: 'getWorkingAreaSize',
	    value: function getWorkingAreaSize() {
	      var el = document.createElement('div');
	      var styles = 'width:100%;height:100%;position:fixed;left:0;top:0;z-index:-1';

	      el.setAttribute('style', styles);

	      document.body.appendChild(el);

	      var width = el.offsetWidth,
	          height = el.offsetHeight;

	      // Clean up
	      document.body.removeChild(el);

	      return { width: width, height: height };
	    }

	    /**
	     * Get navigator information
	     *
	     * @return {object} - object with navigator information
	     */

	  }, {
	    key: 'getNavigatorInfo',
	    value: function getNavigatorInfo() {
	      var navigatorInfo = {};

	      var key = void 0,
	          option = void 0,
	          i = void 0;

	      for (i = 0; i < c.NAVIGATOR_OPTIONS.length; i++) {
	        key = c.NAVIGATOR_OPTIONS[i];
	        option = window.navigator[key];

	        if (isExist(option)) {
	          navigatorInfo[key] = option;
	        }
	      }

	      return navigatorInfo;
	    }

	    /**
	     * Get user language
	     *
	     * @return {string} - user language
	     */

	  }, {
	    key: 'getLanguage',
	    value: function getLanguage() {
	      return window.navigator.language;
	    }

	    /**
	     * Get instaled languages
	     *
	     * @return {array} - array of languages
	     */

	  }, {
	    key: 'getLanguages',
	    value: function getLanguages() {
	      return window.navigator.languages;
	    }

	    /**
	     * Get instaled languages as string
	     *
	     * @return {string} - string with languages
	     */

	  }, {
	    key: 'getLanguagesString',
	    value: function getLanguagesString() {
	      return this.getLanguages().join(', ');
	    }

	    /**
	     * Get battery information
	     *
	     * @return {Promise}
	     */

	  }, {
	    key: 'getBatteryInfo',
	    value: function getBatteryInfo() {
	      var navigator = window.navigator;
	      var batteryInfo = {};
	      var batteryOptions = {
	        mozBattery: 'Mozilla',
	        webkitBattery: 'WebKit',
	        battery: 'W3C'
	      };

	      var isDesktop = function isDesktop(battery) {
	        return battery.charging && battery.chargingTime === 0 && battery.dischargingTime === Infinity && battery.level === 1;
	      };

	      return new Promise(function (resolve, reject) {
	        if (isExist(navigator.getBattery)) {
	          try {
	            (function () {
	              var batteryInterval = window.setTimeout(function () {
	                resolve(batteryInfo);
	              }, 1000);

	              navigator.getBattery().then(function (battery) {
	                batteryInfo['vendor'] = 'W3C';
	                batteryInfo['charging'] = battery.charging;
	                batteryInfo['chargingTime'] = battery.chargingTime;
	                batteryInfo['dischargingTime'] = battery.dischargingTime;
	                batteryInfo['level'] = battery.level;
	                batteryInfo['isDesktop'] = isDesktop(battery);

	                clearInterval(batteryInterval);

	                resolve(batteryInfo);
	              });
	            })();
	          } catch (error) {
	            resolve(batteryInfo);
	          }
	        } else {
	          for (var key in batteryOptions) {
	            var battery = navigator[key];

	            if (battery) {
	              batteryInfo['vendor'] = batteryOptions[key] + ' (Legacy)';
	              batteryInfo['charging'] = battery.charging;
	              batteryInfo['chargingTime'] = battery.chargingTime;
	              batteryInfo['dischargingTime'] = battery.dischargingTime;
	              batteryInfo['level'] = battery.level;
	              batteryInfo['isDesktop'] = isDesktop(battery);

	              resolve(batteryInfo);

	              break;
	            }
	          }
	        }
	      });
	    }

	    /**
	     * Get memory performance snapshot
	     *
	     * @return {object} - memory performance snapshot
	     */

	  }, {
	    key: 'getMemoryPerformance',
	    value: function getMemoryPerformance() {
	      var memory = window.performance ? window.performance.memory : null;

	      if (isExist(memory)) {
	        return {
	          jsHeapSizeLimit: memory.jsHeapSizeLimit,
	          totalJSHeapSize: memory.totalJSHeapSize,
	          usedJSHeapSize: memory.usedJSHeapSize
	        };
	      }

	      return null;
	    }

	    /**
	     * Get navigation performance snapshot
	     *
	     * @return {object} - navigation performance snapshot
	     */

	  }, {
	    key: 'getNavigationPerformance',
	    value: function getNavigationPerformance() {
	      var navigation = window.performance ? window.performance.navigation : {};

	      if (isExist(navigation.type)) {
	        var type = void 0,
	            body = void 0,
	            redirectCount = navigation.redirectCount;

	        switch (navigation.type) {
	          case 0:
	            type = 'TYPE_NAVIGATE';
	            body = 'Navigation started by clicking on a link, or entering the URL in the address bar, or form submission, or initializing through a script operation.';
	            break;

	          case 1:
	            type = 'TYPE_RELOAD';
	            body = 'Navigation through the reload operation or the location.reload method.';
	            break;

	          case 2:
	            type = 'TYPE_BACK_FORWARD';
	            body = 'Navigation through a history traversal operation.';
	            break;

	          default:
	            type = 'TYPE_UNDEFINED';
	            body = 'Any navigation types not defined by values above.';
	        }

	        return {
	          type: type,
	          body: body,
	          redirectCount: redirectCount
	        };
	      }

	      return null;
	    }

	    /**
	     * Calculate timing performance
	     *
	     * @param {object} data - window performance object
	     * @return {object} - object that contains timeline performance
	     */

	  }, {
	    key: '_calculateTimingPerformance',
	    value: function _calculateTimingPerformance(data) {
	      var prev_value = 0;
	      var total_timeline = 0;

	      var result = {};

	      var i = void 0,
	          option = void 0;

	      for (i = 0; i < c.PERFOMANCE_TIMING_OPTIONS.length; i++) {
	        option = c.PERFOMANCE_TIMING_OPTIONS[i];

	        var value = data.timing[option],
	            timelineDelta = 0,
	            timelineCurrent = 0;

	        top: {
	          if (isExist(value)) {
	            timelineCurrent = total_timeline;
	            timelineDelta = value === 0 || prev_value === 0 ? 0 : value - prev_value;

	            prev_value = value;
	            total_timeline += timelineDelta;

	            if (option === 'unloadEventStart' || option === 'unloadEventEnd' || option === 'msFirstPaint') {
	              prev_value = 0, total_timeline = 0;
	            }
	          } else if (option === 'msFirstPaint') {
	            option = null;
	            break top;
	          } else {
	            value = timelineDelta = timelineCurrent = null;
	          }
	        }

	        if (option) {
	          result[option] = [value, timelineCurrent, timelineDelta];
	        }
	      }

	      return result;
	    }

	    /**
	     * Get performance
	     *
	     * @return {Promise}
	     */

	  }, {
	    key: 'geTimingPerformance',
	    value: function geTimingPerformance() {
	      var _this = this;

	      return new Promise(function (resolve, reject) {
	        if (isExist(performance)) {
	          try {
	            window.onload = function () {
	              setTimeout(function () {
	                resolve(_this._calculateTimingPerformance(window.performance));
	              }, 100);
	            };

	            _this._calculateTimingPerformance(window.performance);
	          } catch (error) {
	            resolve('Performance API is not supported');
	          }
	        } else {
	          resolve('Performance API is not supported');
	        }
	      });
	    }

	    /**
	     * Get global permissions
	     *
	     * @return {Promise}
	     */

	  }, {
	    key: 'getGlobalPermissions',
	    value: function getGlobalPermissions() {
	      var _this2 = this;

	      var globalPermissions = {
	        permissions_vendor: 'W3C',
	        geolocation: {},
	        notifications: {},
	        midi: {},
	        midi_sysex: {},
	        push: {}
	      };

	      return new Promise(function (resolve, reject) {
	        var handleMessage = function handleMessage(res) {
	          if ('https://permissions-api.github.io' == res.origin || 'http://permissions-api.github.io' == res.origin) {
	            for (var key in res.data) {
	              globalPermissions[key] = res.data[key];
	            }
	          }

	          resolve(globalPermissions);
	        };

	        if (isExist(_this2.permDone)) {
	          perm_iframe.contentWindow.postMessage('repeat', '*');
	        } else {
	          var el = document.createElement('div');

	          el.setAttribute('style', 'display:none');
	          el.innerHTML = '<iframe id="perm_iframe" src="https://permissions-api.github.io/query/all.html"></iframe>';

	          document.body.appendChild(el);

	          window.addEventListener('message', handleMessage, false);
	          window.addEventListener('onmessage', handleMessage, false);

	          _this2.permDone = true;
	        }
	      });
	    }
	  }, {
	    key: 'getNavigatorPermissions',


	    /**
	     * Navigator permissions
	     *
	     * @return {Promise}
	     */
	    value: function getNavigatorPermissions() {
	      var permissions = window.navigator.permissions;

	      return new Promise(function (resolve, reject) {
	        if (isExist(permissions)) {
	          var _ret2 = function () {
	            var parsePermissions = function parsePermissions(perms) {
	              var type = typeof perms[0].state !== 'undefined' ? 'state' : 'status';

	              var getPermisson = function getPermisson(permission, type) {
	                return permission ? permission[type] : null;
	              };

	              return {
	                permissions_vendor: 'W3C',
	                geolocation: getPermisson(perms[0], type),
	                notifications: getPermisson(perms[1], type),
	                midi: getPermisson(perms[2], type),
	                midi_sysex: getPermisson(perms[3], type),
	                push: getPermisson(perms[4], type)
	              };
	            };

	            var promises_array = [permissions.query({ name: 'geolocation' }), permissions.query({ name: 'notifications' }), permissions.query({ name: 'midi' }), permissions.query({ name: 'midi', sysex: true })];

	            if (navigator.userAgent.indexOf('OPR') === -1) {
	              promises_array.push(permissions.query({ name: 'push', userVisibleOnly: true, userVisible: true }));
	            }

	            return {
	              v: Promise.all(promises_array).then(function (perms) {
	                resolve(parsePermissions(perms));
	              }).catch(function (error) {
	                resolve('Error getting permissions');
	              })
	            };
	          }();

	          if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	        } else {
	          resolve('Permissions API is not supported');
	        }
	      });
	    }

	    /**
	     * Detect webGl support
	     *
	     * @return {object} - webGl info
	     */

	  }, {
	    key: 'detectWebGl',
	    value: function detectWebGl() {
	      var webglObj = (0, _webgldetect2.default)();

	      var webgl = Object.assign({}, webglObj);

	      if (webglObj.status && !webglObj.disabled) {
	        var gl = document.createElement('canvas').getContext(webglObj.name);

	        webgl = Object.assign({}, webglObj, {
	          version: gl.getParameter(gl.VERSION),
	          shading_language_version: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
	          vendor: gl.getParameter(gl.VENDOR),
	          renderer: gl.getParameter(gl.RENDERER)
	        });
	      }

	      return webgl;
	    }
	  }]);

	  return ClientInfo;
	}();

	exports.default = ClientInfo;

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * JavaScript code to detect available availability of a
	 * particular font in a browser using JavaScript and CSS.
	 *
	 * Author : Lalit Patel
	 * Website: http://www.lalit.org/lab/javascript-css-font-detect/
	 * License: Apache Software License 2.0
	 *          http://www.apache.org/licenses/LICENSE-2.0
	 * Version: 0.15 (21 Sep 2009)
	 *          Changed comparision font to default from sans-default-default,
	 *          as in FF3.0 font of child element didn't fallback
	 *          to parent element if the font is missing.
	 * Version: 0.2 (04 Mar 2012)
	 *          Comparing font against all the 3 generic font families ie,
	 *          'monospace', 'sans-serif' and 'sans'. If it doesn't match all 3
	 *          then that font is 100% not available in the system
	 * Version: 0.3 (24 Mar 2012)
	 *          Replaced sans with serif in the list of baseFonts
	 */

	/**
	 * Usage: d = new Detector();
	 *        d.detect('font name');
	 */
	var Detector = function Detector() {
	    // a font will be compared against all the three default fonts.
	    // and if it doesn't match all 3 then that font is not available.
	    var baseFonts = ['monospace', 'sans-serif', 'serif'];

	    //we use m or w because these two characters take up the maximum width.
	    // And we use a LLi so that the same matching fonts can get separated
	    var testString = "mmmmmmmmmmlli";

	    //we test using 72px font size, we may use any size. I guess larger the better.
	    var testSize = '72px';

	    var h = document.getElementsByTagName("body")[0];

	    // create a SPAN in the document to get the width of the text we use to test
	    var s = document.createElement("span");
	    s.style.fontSize = testSize;
	    s.innerHTML = testString;
	    var defaultWidth = {};
	    var defaultHeight = {};
	    for (var index in baseFonts) {
	        //get the default width for the three base fonts
	        s.style.fontFamily = baseFonts[index];
	        h.appendChild(s);
	        defaultWidth[baseFonts[index]] = s.offsetWidth; //width for the default font
	        defaultHeight[baseFonts[index]] = s.offsetHeight; //height for the defualt font
	        h.removeChild(s);
	    }

	    function detect(font) {
	        var detected = false;
	        for (var index in baseFonts) {
	            s.style.fontFamily = font + ',' + baseFonts[index]; // name of the font along with the base font for fallback.
	            h.appendChild(s);
	            var matched = s.offsetWidth != defaultWidth[baseFonts[index]] || s.offsetHeight != defaultHeight[baseFonts[index]];
	            h.removeChild(s);
	            detected = detected || matched;
	        }
	        return detected;
	    }

	    this.detect = detect;
	};

	/*** EXPORTS FROM exports-loader ***/
	module.exports = Detector;

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = webglDetector;
	/**
	 * WebGl detector
	 */
	function webglDetector() {
	  var WebGL = { status: false, disabled: true };
	  var names = ['webgl', 'experimental-webgl', 'moz-webgl'];

	  if (!!window.WebGLRenderingContext) {
	    var canvas = document.createElement('canvas'),
	        gl = false,
	        i = void 0;

	    for (i in names) {
	      try {
	        gl = canvas.getContext(names[i]);

	        if (gl && typeof gl.getParameter === 'function') {
	          // WebGL is enabled
	          WebGL.status = true;
	          WebGL.disabled = false;
	          WebGL.name = names[i];

	          return WebGL;
	        }
	      } catch (e) {}
	    }
	    // WebGL is supported, but disabled
	    WebGL.status = true;
	  }

	  // WebGL not supported
	  return WebGL;
	};

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var JS_VERSIONS = exports.JS_VERSIONS = [1.0, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9];

	var RATIOS = exports.RATIOS = {
	  '1.33': '4:3',
	  '1.78': '16:9',
	  '1.6': '16:10',
	  '1.25': '5:4',
	  '1.37': '(Academy ratio)',
	  '1.43': '(IMAX format)',
	  '1.5': '3:2',
	  '1.56': '14:9',
	  '1.66': '(Super16 format)',
	  '1.85': '(35mm standard)',
	  '2.2': '(70mm standard)',
	  '2.35': '(35mm anamorphic pre-1970)',
	  '2.39': '(35mm anamorphic post-1970)'
	};

	var NAVIGATOR_OPTIONS = exports.NAVIGATOR_OPTIONS = ['userAgent', 'appVersion', 'appName', 'appCodeName', 'appMinorVersion', 'product', 'productSub', 'vendor', 'vendorSub', 'buildID', 'platform', 'cpuClass', 'oscpu', 'hardwareConcurrency', 'maxTouchPoints', 'browserLanguage', 'userLanguage', 'systemLanguage', 'onLine', 'doNotTrack', 'msDoNotTrack', 'geolocation', 'cookieEnabled'];

	var PERFOMANCE_TIMING_OPTIONS = exports.PERFOMANCE_TIMING_OPTIONS = ['navigationStart', 'redirectStart', 'redirectEnd', 'fetchStart', 'domainLookupStart', 'domainLookupEnd', 'connectStart', 'secureConnectionStart', 'connectEnd', 'requestStart', 'responseStart', 'responseEnd', 'domLoading', 'domInteractive', 'domContentLoadedEventStart', 'domContentLoadedEventEnd', 'domComplete', 'loadEventStart', 'loadEventEnd', 'msFirstPaint', 'unloadEventStart', 'unloadEventEnd'];

	var FONT_ARRAY = exports.FONT_ARRAY = ['Abadi MT Condensed Light', 'Adobe Fangsong Std', 'Adobe Hebrew', 'Adobe Ming Std', 'Agency FB', 'Aharoni', 'Andalus', 'Angsana New', 'AngsanaUPC', 'Aparajita', 'Arab', 'Arabic Transparent', 'Arabic Typesetting', 'Arial Baltic', 'Arial Black', 'Arial CE', 'Arial CYR', 'Arial Greek', 'Arial TUR', 'Arial', 'Batang', 'BatangChe', 'Bauhaus 93', 'Bell MT', 'Bitstream Vera Serif', 'Bodoni MT', 'Bookman Old Style', 'Braggadocio', 'Broadway', 'Browallia New', 'BrowalliaUPC', 'Calibri Light', 'Calibri', 'Californian FB', 'Cambria Math', 'Cambria', 'Candara', 'Castellar', 'Casual', 'Centaur', 'Century Gothic', 'Chalkduster', 'Colonna MT', 'Comic Sans MS', 'Consolas', 'Constantia', 'Copperplate Gothic Light', 'Corbel', 'Cordia New', 'CordiaUPC', 'Courier New Baltic', 'Courier New CE', 'Courier New CYR', 'Courier New Greek', 'Courier New TUR', 'Courier New', 'DFKai-SB', 'DaunPenh', 'David', 'DejaVu LGC Sans Mono', 'Desdemona', 'DilleniaUPC', 'DokChampa', 'Dotum', 'DotumChe', 'Ebrima', 'Engravers MT', 'Eras Bold ITC', 'Estrangelo Edessa', 'EucrosiaUPC', 'Euphemia', 'Eurostile', 'FangSong', 'Forte', 'FrankRuehl', 'Franklin Gothic Heavy', 'Franklin Gothic Medium', 'FreesiaUPC', 'French Script MT', 'Gabriola', 'Gautami', 'Georgia', 'Gigi', 'Gisha', 'Goudy Old Style', 'Gulim', 'GulimChe', 'GungSeo', 'Gungsuh', 'GungsuhChe', 'Haettenschweiler', 'Harrington', 'Hei S', 'HeiT', 'Heisei Kaku Gothic', 'Hiragino Sans GB', 'Impact', 'Informal Roman', 'IrisUPC', 'Iskoola Pota', 'JasmineUPC', 'KacstOne', 'KaiTi', 'Kalinga', 'Kartika', 'Khmer UI', 'Kino MT', 'KodchiangUPC', 'Kokila', 'Kozuka Gothic Pr6N', 'Lao UI', 'Latha', 'Leelawadee', 'Levenim MT', 'LilyUPC', 'Lohit Gujarati', 'Loma', 'Lucida Bright', 'Lucida Console', 'Lucida Fax', 'Lucida Sans Unicode', 'MS Gothic', 'MS Mincho', 'MS PGothic', 'MS PMincho', 'MS Reference Sans Serif', 'MS UI Gothic', 'MV Boli', 'Magneto', 'Malgun Gothic', 'Mangal', 'Marlett', 'Matura MT Script Capitals', 'Meiryo UI', 'Meiryo', 'Menlo', 'Microsoft Himalaya', 'Microsoft JhengHei', 'Microsoft New Tai Lue', 'Microsoft PhagsPa', 'Microsoft Sans Serif', 'Microsoft Tai Le', 'Microsoft Uighur', 'Microsoft YaHei', 'Microsoft Yi Baiti', 'MingLiU', 'MingLiU-ExtB', 'MingLiU_HKSCS', 'MingLiU_HKSCS-ExtB', 'Miriam Fixed', 'Miriam', 'Mongolian Baiti', 'MoolBoran', 'NSimSun', 'Narkisim', 'News Gothic MT', 'Niagara Solid', 'Nyala', 'PMingLiU', 'PMingLiU-ExtB', 'Palace Script MT', 'Palatino Linotype', 'Papyrus', 'Perpetua', 'Plantagenet Cherokee', 'Playbill', 'Prelude Bold', 'Prelude Condensed Bold', 'Prelude Condensed Medium', 'Prelude Medium', 'PreludeCompressedWGL Black', 'PreludeCompressedWGL Bold', 'PreludeCompressedWGL Light', 'PreludeCompressedWGL Medium', 'PreludeCondensedWGL Black', 'PreludeCondensedWGL Bold', 'PreludeCondensedWGL Light', 'PreludeCondensedWGL Medium', 'PreludeWGL Black', 'PreludeWGL Bold', 'PreludeWGL Light', 'PreludeWGL Medium', 'Raavi', 'Rachana', 'Rockwell', 'Rod', 'Sakkal Majalla', 'Sawasdee', 'Script MT Bold', 'Segoe Print', 'Segoe Script', 'Segoe UI Light', 'Segoe UI Semibold', 'Segoe UI Symbol', 'Segoe UI', 'Shonar Bangla', 'Showcard Gothic', 'Shruti', 'SimHei', 'SimSun', 'SimSun-ExtB', 'Simplified Arabic Fixed', 'Simplified Arabic', 'Snap ITC', 'Sylfaen', 'Symbol', 'Tahoma', 'Times New Roman Baltic', 'Times New Roman CE', 'Times New Roman CYR', 'Times New Roman Greek', 'Times New Roman TUR', 'Times New Roman', 'TlwgMono', 'Traditional Arabic', 'Trebuchet MS', 'Tunga', 'Tw Cen MT Condensed Extra Bold', 'Ubuntu', 'Umpush', 'Univers', 'Utopia', 'Utsaah', 'Vani', 'Verdana', 'Vijaya', 'Vladimir Script', 'Vrinda', 'Webdings', 'Wide Latin', 'Wingdings'];

/***/ }
/******/ ]);